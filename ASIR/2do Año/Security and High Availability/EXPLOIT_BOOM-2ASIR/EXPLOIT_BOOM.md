# Índice

- [EXPLOIT BOOM](#EXPLOIT-BOOM)
    - [Paso 0: Preparar el entorno (Requisitos Previos)](#paso-0-preparar-el-entorno-requisitos-previos)
    - [Estructura de carpetas](#Estructura-de-carpetas)
  - [PARTE A — Inyección SQL (SQL Injection) en Python y Flask](#parte-a--inyección-sql-sql-injection-en-python-y-flask)
    - [A1. Desarrollo de aplicación vulnerable](#A1-Desarrollo-de-aplicación-vulnerable)
    - [A2. Explotación de la vulnerabilidad](#A2-Explotación-de-la-vulnerabilidad)
    - [A3. Corrección y mitigación](#A3-Corrección-y-mitigación)
  - [PARTE B — XSS Reflejado en PHP](#parte-b--xss-reflejado-en-php)
    - [B0. Preparación del Servidor Apache](#B0-Preparación-del-Servidor-Apache)
    - [B1. Desarrollo de aplicación vulnerable](#B1-Desarrollo-de-aplicación-vulnerable)
    - [B2. Explotación de la vulnerabilidad](#B2-Explotación-de-la-vulnerabilidad)
    - [B3. Corrección de la vulnerabilidad](#B3-Corrección-de-la-vulnerabilidad)
  - [PARTE C — Implementación de XSS persistente en Flask](#parte-c--implementación-de-xss-persistente-en-flask)
    - [C0. Limpieza previa](#C0-Limpieza-previa)
    - [C1. Desarrollo de la aplicación vulnerable](#C1-Desarrollo-de-la-aplicación-vulnerable)
    - [C2. Explotación de la vulnerabilidad](#C2-Explotación-de-la-vulnerabilidad)
    - [C3. Corrección y mitigación](#C3-Corrección-y-mitigación)
      - [Comprobación Final](#Comprobación-Final)
- [RESUMEN FINAL](#RESUMEN-FINAL)

---
---

# EXPLOIT BOOM

---
---

### Paso 0: Preparar el entorno (Requisitos Previos)

- sudo apt update
- sudo apt install python3-flask sqlite3 apache2 php libapache2-mod-php -y

### Estructura de carpetas

- mkdir ~/Escritorio/Practica_SAD
- cd ~/Escritorio/Practica_SAD
- mkdir templates

    ![alt text](img/Captura%20desde%202025-11-22%2013-50-26.png)

---
---

## PARTE A — Inyección SQL (SQL Injection) en Python y Flask

### A1. Desarrollo de aplicación vulnerable

1. Crear la plantilla HTML

    ![alt text](img/Captura%20desde%202025-11-22%2013-53-34.png)

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>Login Vulnerable</title>
    </head>
    <body>
        <h2>Sistema de Login (ASIR)</h2>
        <form action="/login" method="post">
            Usuario: <input type="text" name="username"><br>
            Contraseña: <input type="password" name="password"><br><br>
            <input type="submit" value="Entrar">
        </form>
        {% if message %}
        <p><strong>{{ message }}</strong></p>
        {% endif %}
    </body>
    </html>
    ```

2. Crear la aplicación Python Vulnerable

    ![alt text](img/Captura%20desde%202025-11-22%2014-23-54.png)

    ```python
    import sqlite3
    from flask import Flask, request, render_template

    app = Flask(__name__)

    # Función para inicializar la DB con datos de ejemplo
    def init_db():
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute('DROP TABLE IF EXISTS users')
        c.execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)')
        c.execute("INSERT INTO users (username, password) VALUES ('admin', 'supersecreto')")
        c.execute("INSERT INTO users (username, password) VALUES ('pepe', '123456')")
        conn.commit()
        conn.close()

    # Inicializamos la DB al arrancar
    init_db()

    @app.route('/')
    def home():
        return render_template('login.html')

    @app.route('/login', methods=['POST'])
    def login():
        username = request.form['username']
        password = request.form['password']
    
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
    
        # AQUÍ ESTÁ LA VULNERABILIDAD 
        # Concatenamos directamente las variables en la cadena SQL
        query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'"
    
        print(f"Consulta ejecutada: {query}") # Esto lo verás en la terminal, muy útil para debug
    
        try:
            c.execute(query)
            user = c.fetchone()<Captura desde 2025-11-25 20-56-46.png>
            conn.close()
        
            if user:
                return render_template('login.html', message=f"¡Bienvenido {user[1]}! Inicio de sesión CORRECTO.")
            else:
                return render_template('login.html', message="Usuario o contraseña incorrectos.")
            
        except Exception as e:
            return render_template('login.html', message=f"Error SQL: {e}")

    if __name__ == '__main__':
        app.run(debug=True, port=5000)
    ```

3. Funcionamiento de la pagina con uno de los usuarios de la base de datos

    ![alt text](img/Captura%20desde%202025-11-25%2020-56-46.png)

---

### A2. Explotación de la vulnerabilidad

1. Ejecutar la app

    ![alt text](img/Captura%20desde%202025-11-22%2014-27-31.png)

2. Abrir el navegador

    ![alt text](img/Captura%20desde%202025-11-22%2014-34-45.png)

3. El Ataque

    ![alt text](img/Captura%20desde%202025-11-22%2014-32-17.png)

    - Al poner ' cerramos la comilla del código SQL original. Al poner -- (en SQL significa "comentario"), hacemos que la base de datos ignore todo lo que viene después (la comprobación de la contraseña).

---

### A3. Corrección y mitigación

1. Código a eliminar

    ```python
    # query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'"
    # c.execute(query)
    ```

2. Código NUEVO (Seguro)

    ```python
    # Usamos ? como placeholder. La librería se encarga de sanitizar.
    query = "SELECT * FROM users WHERE username = ? AND password = ?"
    c.execute(query, (username, password))
    ```

3. Codigo COMPLETO

    ```python
    import sqlite3
    from flask import Flask, request, render_template

    app = Flask(__name__)

    # Función para inicializar la DB con datos de ejemplo
    def init_db():
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute('DROP TABLE IF EXISTS users')
        c.execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)')
        c.execute("INSERT INTO users (username, password) VALUES ('admin', 'supersecreto')")
        c.execute("INSERT INTO users (username, password) VALUES ('pepe', '123456')")
        conn.commit()
        conn.close()

    # Inicializamos la DB al arrancar
    init_db()

    @app.route('/')
    def home():
        return render_template('login.html')

    @app.route('/login', methods=['POST'])
    def login():
        username = request.form['username']
        password = request.form['password']
    
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
    
        # AQUÍ ESTABA LA VULNERABILIDAD
        # query = "SELECT * FROM users WHERE username = '" + username + "' AND password = '" + password + "'"
    
        # NUEVA: Usamos ? como placeholder. La librería se encarga de sanitizar.
        query = "SELECT * FROM users WHERE username = ? AND password = ?"
    
        print(f"Consulta ejecutada (SEGURA): {query}") 
    
        try:
            # Ejecutamos pasando los datos por separado (tupla)
            c.execute(query, (username, password))
        
            user = c.fetchone()
            conn.close()
        
            if user:
                return render_template('login.html', message=f"¡Bienvenido {user[1]}! Inicio de sesión CORRECTO.")
            else:
                return render_template('login.html', message="Usuario o contraseña incorrectos.")
            
        except Exception as e:
            return render_template('login.html', message=f"Error SQL: {e}")

    if __name__ == '__main__':
        app.run(debug=True, port=5000)
    ```

4. Prueba de fuego

    ![alt text](img/Captura%20desde%202025-11-22%2014-58-31.png)

    - Ahora, la base de datos trata admin' -- literalmente como si fuera el nombre de un usuario, no como comandos SQL. Como no existe un usuario con ese nombre exacto, falla.

---
---

## PARTE B — XSS Reflejado en PHP

### B0. Preparación del Servidor Apache

1. Arrancar el servicio Apache

    - sudo service apache2 start

2. Borrar el archivo por defecto (opcional pero recomendado para limpiar)

    - sudo rm /var/www/html/index.html

![alt text](img/Captura%20desde%202025-11-22%2015-03-56.png)

---

### B1. Desarrollo de aplicación vulnerable

1. Crear el archivo

    - sudo nano /var/www/html/search.php

2. Código Vulnerable

    ![alt text](img/Captura%20desde%202025-11-22%2015-14-44.png)

    ```python
    <!DOCTYPE html>
    <html>
    <head>
        <title>Buscador Vulnerable XSS</title>
    </head>
    <body>
        <h1>Buscador de Productos</h1>

        <form method="GET" action="search.php">
            Buscar: <input type="text" name="q">
            <input type="submit" value="Buscar">
        </form>

        <hr>

        <?php
        // Si hay algo en el parámetro 'q' de la URL...
        if (isset($_GET['q'])) {
            $busqueda = $_GET['q'];

            // VULNERABILIDAD
            // Imprimimos directamente lo que el usuario escribió
            // El navegador confiará en este contenido y lo ejecutará si es código.
            echo "Resultados para: " . $busqueda;
        }
        ?>
    </body>
    </html>
    ```

---

### B2. Explotación de la vulnerabilidad

1. Abrir Navegador: http://localhost/search.php

2. En la caja de búsqueda, escribir el siguiente Payload y darle a buscar:

    ```html
    <script>alert('HACKED BY MIGUEL');</script>
    ```

    ![alt text](img/Captura%20desde%202025-11-22%2015-57-33.png)

3. **¿Qué sucede?:** No veremos el texto en la página. En su lugar, saltará una ventana emergente diciendo "HACKED BY MIGUEL".

    ![alt text](img/Captura%20desde%202025-11-22%2016-00-19.png)

    - Acabamos de demostrar que se puede ejecutar código en el navegador de la víctima.

4. Prueba del funcionamiento correcto:

    ![alt text](img/Captura%20desde%202025-11-22%2016-03-48.png)

---

### B3. Corrección de la vulnerabilidad

- Usaremos la función htmlspecialchars(). Esta función convierte los caracteres peligrosos (<, >, &) en texto inofensivo (```&lt;, &gt;```).

1. Editar el archivo

    - sudo nano /var/www/html/search.php

2. Modificar la parte PHP del final

    - Cambiar esto:

    ```php
    echo "Resultados para: " . $busqueda;
    ```

    - Por esto (Solución):

    ```php
    // APLICAMOS SANITIZACIÓN
    // htmlspecialchars convierte <script> en texto plano inocuo
    echo "Resultados para: " . htmlspecialchars($busqueda, ENT_QUOTES, 'UTF-8');
    ```

3. Comprobación

    ![alt text](img/Captura%20desde%202025-11-22%2016-16-23.png)

---
---

## PARTE C — Implementación de XSS persistente en Flask

### C0. Limpieza previa

- Asegurarse de haber detenido el servidor antes arrancado. Ir a la terminal donde se haya ejecutado y pulsar Ctrl + C.

---

### C1. Desarrollo de la aplicación vulnerable

- Se necesita un nuevo script de Python (app_xss.py) y una nueva plantilla HTML (templates/blog.html).

1. Crear la plantilla del Blog

    - nano templates/blog.html

    ![alt text](img/Captura%20desde%202025-11-22%2016-30-49.png)

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>Blog Vulnerable (XSS Persistente)</title>
        <style>
            body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
            .comment-box { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f9f9f9; }
            textarea { width: 100%; height: 80px; }
        </style>
    </head>
    <body>
        <h1>Muro de Comentarios</h1>
    
        <form action="/add" method="post">
            <textarea name="comment" placeholder="Escribe tu comentario..."></textarea><br>
            <input type="submit" value="Publicar Comentario">
        </form>

        <h3>Comentarios recientes:</h3>
    
        {% for row in comments %}
            <div class="comment-box">
                {{ row[1] | safe }}
            </div>
        {% endfor %}
    </body>
    </html>
    ```

2. Crear el Backend en Python

    - nano app_xss.py

    ![alt text](img/Captura%20desde%202025-11-22%2016-33-47.png)

    ```python
    import sqlite3
    from flask import Flask, request, render_template, redirect

    app = Flask(__name__)

    # Inicializar base de datos de comentarios
    def init_db():
        conn = sqlite3.connect('comments.db')
        c = conn.cursor()
        c.execute('DROP TABLE IF EXISTS comments')
        c.execute('CREATE TABLE comments (id INTEGER PRIMARY KEY, content TEXT)')
        # Comentario de prueba normal
        c.execute("INSERT INTO comments (content) VALUES ('Hola, este es un comentario seguro.')")
        conn.commit()
        conn.close()

    init_db()

    @app.route('/')
    def index():
        conn = sqlite3.connect('comments.db')
        c = conn.cursor()
        c.execute("SELECT * FROM comments")
        comments = c.fetchall()
        conn.close()
        return render_template('blog.html', comments=comments)

    @app.route('/add', methods=['POST'])
    def add_comment():
        text = request.form['comment']
        conn = sqlite3.connect('comments.db')
        c = conn.cursor()
        # Insertamos el texto tal cual viene (sin sanitizar en backend)
        # OJO: Aquí usamos parámetros (?) para evitar SQL Injection, 
        # pero eso NO evita el XSS. Son cosas distintas.
        c.execute("INSERT INTO comments (content) VALUES (?)", (text,))
        conn.commit()
        conn.close()
        return redirect('/')

    if __name__ == '__main__':
        app.run(debug=True, port=5000)
    ```

---

### C2. Explotación de la vulnerabilidad

1. Ejecutar la aplicación

    ![alt text](img/Captura%20desde%202025-11-22%2016-43-01.png)

2. Abrir el navegador

    ![alt text](img/Captura%20desde%202025-11-22%2016-47-04.png)

3. El Ataque

    - En la caja de texto escribir el payload malicioso

    ```html
    <script>alert('VIRUS EN EL SISTEMA');</script>
    ```

4. Darle a "Publicar Comentario"

    ![alt text](img/Captura%20desde%202025-11-22%2016-51-24.png)

    - Inmediatamente saltará el popup "VIRUS EN EL SISTEMA". Pero lo más importante que, al recargar la página, el popup vuelve a salir. Si cierras el navegador y vuelves a entrar, el popup vuelve a salir. El código malicioso ahora vive en la base de datos.

    ![alt text](img/Captura%20desde%202025-11-22%2016-54-42.png)

---

### C3. Corrección y mitigación

- Flask usa un motor de plantillas llamado Jinja2. Jinja2 es inteligente por defecto, siempre escapa el código HTML para protegernos.

- La vulnerabilidad la creamos nosotros mismos al poner ```| safe``` en el archivo HTML. Ese comando fuerza a Flask a ser inseguro. La solución es tan simple como quitarlo y dejar que Flask haga su trabajo.

1. Detener el servidor Ctrl + C

2. Editar el HTML

    - nano templates/blog.html

3. Buscar la línea vulnerable y quitar el filtro ```| safe```

    ![alt text](img/Captura%20desde%202025-11-22%2017-06-17.png)

    ```html
    <!DOCTYPE html>
    <html>
    <head>
        <title>Blog Vulnerable (XSS Persistente)</title>
        <style>
            body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
            .comment-box { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f9f9f9; }
            textarea { width: 100%; height: 80px; }
        </style>
    </head>
    <body>
        <h1>Muro de Comentarios</h1>
    
        <form action="/add" method="post">
            <textarea name="comment" placeholder="Escribe tu comentario..."></textarea><br>
            <input type="submit" value="Publicar Comentario">
        </form>

        <h3>Comentarios recientes:</h3>
    
        {% for row in comments %}
            <div class="comment-box">
                {{ row[1] }} <!-- {{ row[1] | safe }} -->
            </div>
        {% endfor %}
    </body>
    </html>
    ```

4. Guardar y Salir

#### Comprobación Final

1. Arrancar python3 app_xss.py

2. Ir al navegador

3. Ya no saltará el popup

4. Ahora, en la lista de comentarios, se verá escrito literalmente ```<script>alert('VIRUS EN EL SISTEMA');</script>```

    ![alt text](img/Captura%20desde%202025-11-22%2017-14-05.png)

---
---

# RESUMEN FINAL

- **SQL Injection:** Engañar a la base de datos para entrar sin contraseña.
    - **Solución:** Consultas preparadas (?).

- **XSS Reflejado:** Ejecutar script rebotándolo en la URL. 
    - **Solución:** Sanitizar salida (htmlspecialchars).

- **XSS Persistente:** Guardar script en la DB para atacar a todos.   
    - **Solución:** Escapar caracteres automáticos en las plantillas (No usar safe).



























   








